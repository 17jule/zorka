/**
 * Copyright 2012-2014 Rafal Lewczuk <rafal.lewczuk@jitlogic.com>
 *
 * ZORKA is free software. You can redistribute it and/or modify it under the
 * terms of the GNU General Public License as published by the Free Software
 * Foundation, either version 3 of the License, or (at your option) any later
 * version.
 *
 * ZORKA is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
 * details.
 *
 * You should have received a copy of the GNU General Public License along with
 * ZORKA. If not, see <http://www.gnu.org/licenses/>.
 */


zorka.require("soap.bsh", "apache/apache.bsh");

__cxf() {


  _trace_begin() {
    process(rec) {

      if ("org.apache.cxf.binding.soap.SoapMessage".equals(rec.get("MSG").getClass().getName())) {
        tracer.traceBegin("SOAP", soap._time);
      }

      return rec;
    }
    return (com.jitlogic.zorka.core.spy.SpyProcessor)this;
  }

  encodings = util.set("UTF-8", "UTF-16");

  slurp(msg, limit) {
    contents = util.getField(msg, "contents");
    is = null; isc = null;

    if (contents != null) {
      for (i = 1; i < contents.length; i += 2) {
        c = contents[i];
        if (c instanceof java.io.InputStream) {
          is = c; isc = contents[i-1]; break;
        }
      }
    }

    if (is != null) {
      bos = msg.getClass().getClassLoader().loadClass("org.apache.cxf.io.CachedOutputStream").newInstance();
      ids = is.getClass().getName().endsWith("DelegatingInputStream");
      bis = ids ? is.getInputStream() : is;
      try {
        util.ioCopy(bis, bos);
      } finally {
        bis.close();
      }
      bis = bos.getInputStream();
      if (ids) {
        is.setInputStream(bis);
      } else {
        msg.setContent(isc, bis);
      }
      len = util.min(bos.size(), limit);
      byte[] buf = new byte[len];
      n = bos.getInputStream().read(buf);
      if (n != len) {
        buf = util.clipArray(buf, n);
      }
      enc = msg.get("org.apache.cxf.message.Message.ENCODING");
      if (encodings.contains(enc)) {
        return new String(buf, enc);
      } else {
        return util.base64(buf);
      }
    } else {

    }
    return null;
  }


  _trace_submit() {


    process(rec) {

      msg = rec.get("MSG");
      msg_in = msg.getExchange().getInMessage();

      if (msg_in != null && "org.apache.cxf.binding.soap.SoapMessage".equals(msg_in.getClass().getName())) {
        tracer.traceBegin("SOAP", soap._time);
        service = msg_in.get("org.apache.cxf.request.url");
        tracer.newAttr("SERVICE", service); rec.put("SERVICE", service);
        method = msg_in.get("javax.xml.ws.wsdl.operation").getLocalPart();
        tracer.newAttr("METHOD", method); rec.put("METHOD", method);
        if (soap._fetch_xml_in) {
          xml_in = slurp(msg_in, soap._fetch_xml_limit);
          tracer.newAttr("XML_IN", xml_in); rec.put("XML_IN", xml_in);
        }
      }

      msg_out = msg.getExchange().getOutMessage();

      //if (msg_out != null && "org.apache.cxf.binding.soap.SoapMessage".equals(msg_in.getClass().getName())) {
      //}

      //err_in = msg.getExchange().getInFaultMessage();
      //err_out = msg.getExchange().getOutFaultMessage();

      return rec;
    }

    return (com.jitlogic.zorka.core.spy.SpyProcessor)this;
  }

  spy.add(spy.instrument("CXF_MESSAGE_1")
    .onEnter(spy.fetchArg("MSG", 1),
      soap._trace ? _trace_begin() : null)
    .onError(tracer.markError())
    .onSubmit(soap._trace ? _trace_submit() : null)
    .include(spy.byMethod("org.apache.cxf.transport.ChainInitiationObserver", "onMessage")));


  tracer.exclude(
    "org.apache.cxf.bus.extension.Extension",
    "org.apache.cxf.common.logging.**",
    "org.apache.cxf.message.MessageImpl",
    "org.apache.cxf.message.StringMapImpl",
    "org.apache.cxf.helpers.HttpHeaderHelper",
    "org.apache.cxf.phase.Phase",
    "org.apache.cxf.common.util.**"
  );


  return this;
}

cxf = __cxf();

// "org.apache.cxf.**",
