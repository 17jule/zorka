/**
 * Copyright 2012-2014 Rafal Lewczuk <rafal.lewczuk@jitlogic.com>
 *
 * ZORKA is free software. You can redistribute it and/or modify it under the
 * terms of the GNU General Public License as published by the Free Software
 * Foundation, either version 3 of the License, or (at your option) any later
 * version.
 *
 * ZORKA is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
 * details.
 *
 * You should have received a copy of the GNU General Public License along with
 * ZORKA. If not, see <http://www.gnu.org/licenses/>.
 */


zorka.require("soap.bsh", "apache/apache.bsh");

__cxf() {

  _cxf_enter() {
    process(rec) {

      if ("org.apache.cxf.binding.soap.SoapMessage".equals(rec.get("MSG").getClass().getName())) {
        tracer.traceBegin("SOAP", soap._time);
      }

      return rec;
    }
    return (com.jitlogic.zorka.core.spy.SpyProcessor)this;
  }


  _tap_cxf_input() {
    process(rec) {
      msg = rec.get("MSG");

      contents = util.getField(msg, "contents");
      is = null; isc = null; isx = -1;

      // TODO fetching it manually is propably not a good idea; use getContent()/setContent() instead
      if (contents != null) {
        for (i = 1; i < contents.length; i += 2) {
          c = contents[i];
          if (c instanceof java.io.InputStream) {
            is = c; isc = contents[i-1]; isx = i; break;
          }
        }
      }

      if (is != null) {
        if (isc.getName().endsWith("DelegatingInputStream")) {
          zorka.logInfo("DELEGATING");
          tap = util.tapInputStream(is.getInputStream(), 512, 65536);
          is.setInputStream(tap);
          rec.put("TAP_IN", tap);
        } else {
          zorka.logInfo("NON-DELEGATING");
          tap = util.tapInputStream(is, 512, 65536);
          contents[isx] = tap;
          rec.put("TAP_IN", tap);
        }
      }

      return rec;
    }
    return (com.jitlogic.zorka.core.spy.SpyProcessor)this;
  }

  _msg_tap_out = new ThreadLocal();

  _tap_cxf_output() {
    process(rec) {
      msg = rec.get("MSG").getExchange().getOutMessage();

      contents = util.getField(msg, "contents");
      os = null; osc = null; osx = -1;

      // TODO fetching it manually is propably not a good idea; use getContent()/setContent() instead
      if (contents != null) {
        for (i = 1; i < contents.length; i += 2) {
          c = contents[i];
          if (c instanceof java.io.OutputStream) {
            os = c; osc = contents[i-1]; osx = i; break;
          }
        }
      }

      if (os != null) {
        tap_out = util.tapOutputStream(os, 512, 65536);
        _msg_tap_out.set(tap_out);
        contents[osx] = tap_out;
        zorka.logInfo("Intercepted output stream.");
      }

      return rec;
    }
    return (com.jitlogic.zorka.core.spy.SpyProcessor)this;
  }


  _cxf_submit() {

    process(rec) {

      msg = rec.get("MSG");
      msg_in = msg.getExchange().getInMessage();

      if (msg_in != null && "org.apache.cxf.binding.soap.SoapMessage".equals(msg_in.getClass().getName())) {
        tracer.traceBegin("SOAP", soap._time);
        service = msg_in.get("org.apache.cxf.request.url");
        tracer.newAttr("SERVICE", service); rec.put("SERVICE", service);
        method = msg_in.get("javax.xml.ws.wsdl.operation").getLocalPart();
        tracer.newAttr("METHOD", method); rec.put("METHOD", method);
        encoding = msg_in.get("org.apache.cxf.message.Message.ENCODING");
        tracer.newAttr("ENC_IN", encoding);

        tap_in = rec.get("TAP_IN");
        if (tap_in != null) {
          xml_in = tap_in.asString(encoding);
          tracer.newAttr("XML_IN", xml_in); rec.put("XML_IN", xml_in);
        }

        tap_out = _msg_tap_out.get();
        if (tap_out != null) {
          xml_out = tap_out.asString(encoding);
          tracer.newAttr("XML_OUT", xml_out); rec.put("XML_OUT", xml_out);
        }

        _msg_tap_out.remove();
      }

      //msg_out = msg.getExchange().getOutMessage();
      //err_in = msg.getExchange().getInFaultMessage();
      //err_out = msg.getExchange().getOutFaultMessage();

      return rec;
    }

    return (com.jitlogic.zorka.core.spy.SpyProcessor)this;
  }


  if (soap._fetch_xml_out) {
    spy.add(spy.instance("CXF_MESSAGE_OUT_TAP")
      .onEnter(spy.fetchArg("MSG", 1))
      .onReturn(_tap_cxf_output())
      .include(spy.byMethod("org.apache.cxf.interceptor.MessageSenderInterceptor", "handleMessage")));
  }


  spy.add(spy.instrument("CXF_MESSAGE_IN_OUT_GLOBAL")
    .onEnter(spy.fetchArg("MSG", 1),
      soap._trace ? _cxf_enter() : null,
      soap._fetch_xml_in ? _tap_cxf_input() : null)
    .onError(tracer.markError())
    .onSubmit(soap._trace ? _cxf_submit() : null)
    .include(spy.byMethod("org.apache.cxf.transport.ChainInitiationObserver", "onMessage")));


  tracer.exclude(
    "org.apache.cxf.bus.extension.Extension",
    "org.apache.cxf.common.logging.**",
    "org.apache.cxf.message.MessageImpl",
    "org.apache.cxf.message.StringMapImpl",
    "org.apache.cxf.helpers.HttpHeaderHelper",
    "org.apache.cxf.phase.Phase",
    "org.apache.cxf.common.util.**"
  );


  return this;
}

cxf = __cxf();

// "org.apache.cxf.**",
