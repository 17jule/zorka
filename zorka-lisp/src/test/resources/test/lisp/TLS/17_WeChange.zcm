; /**
;  * From book: The Seasoned Schemer, by Daniel P. Friedman and Matthias Felleisen.
;  *
;  * Chapter 17: We Change Therefor We Are
;  */


(defn deep (m)
  (if (zero? m) 'pizza (cons (deep (dec m)) nil)))

(defn find (n Ns Rs)
  (letrec
    ((A (lambda (ns rs)
          (cond
            ((null? ns) nil)
            ((= (car ns) n) (car rs))
            (else (A (cdr ns) (cdr rs)))))))
    (A Ns Rs)))



; We start refactoring with function below;

(define deepM
  (let ((Rs '()) (Ns '()))
    (letrec
      ((D (lambda (m)
            (if (zero? m)
              'pizza
              (cons (D (dec m)) nil)))))
      (lambda (n)
        (let ((exists (find n Ns Rs)))
          (if (null? exists)
            (let ((result (D n)))
              (set! Rs (cons result Rs))
              (set! Ns (cons n Ns))
              result)
            exists))))))

(deftest test-deepM-1
  (is= '(((pizza))) (deepM 3))
  (is= '((pizza)) (deepM 2)))


; We improve its performance a bit

(define deepM
  (let ((Rs '()) (Ns '()))
    (letrec
      ((D (lambda (m)
            (if (zero? m)
              'pizza
              (cons (deepM (dec m)) nil)))))
      (lambda (n)
        (let ((exists (find n Ns Rs)))
          (if (null? exists)
            (let ((result (D n)))
              (set! Rs (cons result Rs))
              (set! Ns (cons n Ns))
              result)
            exists))))))

(deftest test-deepM-2
  (is= '(((pizza))) (deepM 3))
  (is= '((pizza)) (deepM 2)))


; No need for letrec, use let instead

(define deepM
  (let ((Rs '()) (Ns '()))
    (let
      ((D (lambda (m)
            (if (zero? m)
              'pizza
              (cons (deepM (dec m)) nil)))))
      (lambda (n)
        (let ((exists (find n Ns Rs)))
          (if (null? exists)
            (let ((result (D n)))
              (set! Rs (cons result Rs))
              (set! Ns (cons n Ns))
              result)
            exists))))))

(deftest test-deepM-3
  (is= '(((pizza))) (deepM 3))
  (is= '((pizza)) (deepM 2)))



; Now collapse two unrelated let into one

(define deepM
 (let ((Rs '())
       (Ns '())
       (D (lambda (m)
            (if (zero? m)
              'pizza
              (cons (deepM (dec m)) nil)))))
   (lambda (n)
     (let ((exists (find n Ns Rs)))
       (if (null? exists)
         (let ((result (D n)))
           (set! Rs (cons result Rs))
           (set! Ns (cons n Ns))
           result)
       exists)))))

(deftest test-deepM-4
  (is= '(((pizza))) (deepM 3))
  (is= '((pizza)) (deepM 2)))


; Here we can inline D

(define deepM
 (let ((Rs '())
       (Ns '()))
   (lambda (n)
     (let ((exists (find n Ns Rs)))
       (if (null? exists)
         (let ((result ((lambda (m)
                          (if (zero? m)
                            'pizza
                            (cons (deepM (dec m)) nil)))
                         n)))
           (set! Rs (cons result Rs))
           (set! Ns (cons n Ns))
           result)
       exists)))))

(deftest test-deepM-5
  (is= '(((pizza))) (deepM 3))
  (is= '((pizza)) (deepM 2)))



; ... here we get rid of redundant lambda ...

(define deepM
 (let ((Rs '())
       (Ns '()))
   (lambda (n)
     (let ((exists (find n Ns Rs)))
       (if (null? exists)
         (let ((result (let ((m n))
                         (if (zero? m) 'pizza (cons (deepM (dec m)))))))
           (set! Rs (cons result Rs))
           (set! Ns (cons n Ns))
           result)
       exists)))))

(deftest test-deepM-6
  (is= '(((pizza))) (deepM 3))
  (is= '((pizza)) (deepM 2)))



; ... and now get rid of redundant let ...

(define deepM
 (let ((Rs '())
       (Ns '()))
   (lambda (n)
     (let ((exists (find n Ns Rs)))
       (if (null? exists)
         (let ((result (if (zero? n) 'pizza (cons (deepM (dec n))))))
           (set! Rs (cons result Rs))
           (set! Ns (cons n Ns))
           result)
       exists)))))

(deftest test-deepM-7
  (is= '(((pizza))) (deepM 3))
  (is= '((pizza)) (deepM 2)))


(define counter)

(define consC
  (let ((N 0))
    (set! counter (lambda() N))
    (lambda (x y)
      (set! N (inc N))
      (cons x y))))

(defn deep (m)
  (if (zero? m) 'pizza (consC (deep (dec m)) nil)))

(deftest test-deep-with-consC
  (is= '(((pizza))) (deep 3))
  (is= 3 (counter))
  (is= '((pizza)) (deep 2))
  (is= 5 (counter)))

(defn supercounter (f)
  (letrec
    ((S (lambda (n)
          (if (zero? n)
            (f n)
            (begin (f n) (S (dec n)))))))
    (S 100)))

(deftest test-supercounter
  (supercounter deep)
  (is= 5055 (counter)))

(define set-counter)

(define consC
  (let ((N 0))
    (set! counter
      (lambda () N))
    (set! set-counter
      (lambda (n)
        (set! N n)))
    (lambda (x y)
      (set! N (inc N))
      (cons x y))))


(deftest test-deep-with-consC-2
  (is= '(((pizza))) (deep 3))
  (is= 3 (counter))
  (is= '((pizza)) (deep 2))
  (is= 5 (counter))
  (set-counter 0)
  (is= 0 (counter))
  (supercounter deep)
  (is= 5050 (counter)))


; ... and now counting conses ...

(define deepM
 (let ((Rs '())
       (Ns '()))
   (lambda (n)
     (let ((exists (find n Ns Rs)))
       (if (null? exists)
         (let ((result (if (zero? n) 'pizza (consC (deepM (dec n))))))
           (set! Rs (cons result Rs))
           (set! Ns (cons n Ns))
           result)
       exists)))))


; A LISP programmer knows the value of everything but the cost of nothing
; Alan J. Perlis (1922-1990)

(deftest test-deepM-with-consC
  (set-counter 0)
  (is= '(((((pizza))))) (deepM 5))
  (is= 5 (counter))
  (is= '(((pizza))) (deepM 3))
  (is= 5 (counter))
  (is= '(((((((pizza))))))) (deepM 7))
  (is= 7 (counter))
  (supercounter deepM)
  (is= 100 (counter)))


(defn rember1*C (a l)
  (letrec
    ((R (lambda (l oh)
          (cond
            ((null? l) (oh 'no))
            ((atom? (car l))
              (if (eq? (car l) a)
                (cdr l)
                (consC (car l) (R (cdr l) oh))))
            (else
              (let ((new-car (letcc oh (R (car l) oh))))
                (if (atom? new-car)
                  (consC (car l) (R (cdr l) oh))
                  (consC new-car (cdr l)))))))))
    (let ((new-l (letcc oh (R l oh))))
      (if (atom? new-l) l new-l))))


(deftest test-rember1*C-fn
  (set-counter 0)
  (is=
    '((Swedish rye) (French (mustard turkey)) salad)
    (rember1*C 'salad '((Swedish rye) (French (mustard salad turkey)) salad)))
  (is= 5 (counter))
  (set-counter 0)
  (is=
    '((pasta) pasta (noodles meat sauce) meat tomatoes)
    (rember1*C 'meat '((pasta meat) pasta (noodles meat sauce) meat tomatoes)))
  (is= 2 (counter))
  (set-counter 0)
  (is=
    '((food) more (food))
    (rember1*C 'noodles '((food) more (food))))
  (is= 0 (counter)))


(defn rember1*C2 (a l)
  (letrec
    ((R (lambda (l)
          (cond
            ((null? l) nil)
            ((atom? (car l))
              (cond
                ((eq? (car l) a) (cdr l))
                (else (consC (car l) (R (cdr l))))))
            (else
              (let ((av (R (car l))))
                (cond
                  ((equal? av (car l))
                    (consC (car l) (R (cdr l))))
                  (else
                    (consC av (cdr l))))))))))
    (R l)))

(deftest test-rember2*C-fn
  (set-counter 0)
  (is=
    '((Swedish rye) (French (mustard turkey)) salad)
    (rember1*C2 'salad '((Swedish rye) (French (mustard salad turkey)) salad)))
  (is= 7 (counter))
  (set-counter 0)
  (is=
    '((pasta) pasta (noodles meat sauce) meat tomatoes)
    (rember1*C2 'meat '((pasta meat) pasta (noodles meat sauce) meat tomatoes)))
  (is= 2 (counter))
  (set-counter 0)
  (is=
    '((food) more (food))
    (rember1*C2 'noodles '((food) more (food))))
  (is= 5 (counter)))


