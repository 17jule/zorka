; /**
;  * From book: The Seasoned Schemer, by Daniel P. Friedman and Matthias Felleisen.
;  *
;  * Chapter 17: We Change Therefor We Are
;  */


(defn deep (m)
  (if (zero? m) 'pizza (cons (deep (dec m)) nil)))

(defn find (n Ns Rs)
  (letrec
    ((A (fn (ns rs)
          (cond
            ((null? ns) nil)
            ((= (car ns) n) (car rs))
            (else (A (cdr ns) (cdr rs)))))))
    (A Ns Rs)))



; We start refactoring with function below;

(def deepM
  (let ((Rs '()) (Ns '()))
    (letrec
      ((D (fn (m)
            (if (zero? m)
              'pizza
              (cons (D (dec m)) nil)))))
      (fn (n)
        (let ((exists (find n Ns Rs)))
          (if (null? exists)
            (let ((result (D n)))
              (set! Rs (cons result Rs))
              (set! Ns (cons n Ns))
              result)
            exists))))))

(deftest test-deepM-1
  (is= '(((pizza))) (deepM 3))
  (is= '((pizza)) (deepM 2)))


; We improve its performance a bit

(def deepM
  (let ((Rs '()) (Ns '()))
    (letrec
      ((D (fn (m)
            (if (zero? m)
              'pizza
              (cons (deepM (dec m)) nil)))))
      (fn (n)
        (let ((exists (find n Ns Rs)))
          (if (null? exists)
            (let ((result (D n)))
              (set! Rs (cons result Rs))
              (set! Ns (cons n Ns))
              result)
            exists))))))

(deftest test-deepM-2
  (is= '(((pizza))) (deepM 3))
  (is= '((pizza)) (deepM 2)))


; No need for letrec, use let instead

(def deepM
  (let ((Rs '()) (Ns '()))
    (let
      ((D (fn (m)
            (if (zero? m)
              'pizza
              (cons (deepM (dec m)) nil)))))
      (fn (n)
        (let ((exists (find n Ns Rs)))
          (if (null? exists)
            (let ((result (D n)))
              (set! Rs (cons result Rs))
              (set! Ns (cons n Ns))
              result)
            exists))))))

(deftest test-deepM-3
  (is= '(((pizza))) (deepM 3))
  (is= '((pizza)) (deepM 2)))



; Now collapse two unrelated let into one

(def deepM
 (let ((Rs '())
       (Ns '())
       (D (fn (m)
            (if (zero? m)
              'pizza
              (cons (deepM (dec m)) nil)))))
   (fn (n)
     (let ((exists (find n Ns Rs)))
       (if (null? exists)
         (let ((result (D n)))
           (set! Rs (cons result Rs))
           (set! Ns (cons n Ns))
           result)
       exists)))))

(deftest test-deepM-4
  (is= '(((pizza))) (deepM 3))
  (is= '((pizza)) (deepM 2)))


; Here we can inline D

(def deepM
 (let ((Rs '())
       (Ns '()))
   (fn (n)
     (let ((exists (find n Ns Rs)))
       (if (null? exists)
         (let ((result ((fn (m)
                          (if (zero? m)
                            'pizza
                            (cons (deepM (dec m)) nil)))
                         n)))
           (set! Rs (cons result Rs))
           (set! Ns (cons n Ns))
           result)
       exists)))))

(deftest test-deepM-5
  (is= '(((pizza))) (deepM 3))
  (is= '((pizza)) (deepM 2)))



; ... here we get rid of redundant fn ...

(def deepM
 (let ((Rs '())
       (Ns '()))
   (fn (n)
     (let ((exists (find n Ns Rs)))
       (if (null? exists)
         (let ((result (let ((m n))
                         (if (zero? m) 'pizza (cons (deepM (dec m)))))))
           (set! Rs (cons result Rs))
           (set! Ns (cons n Ns))
           result)
       exists)))))

(deftest test-deepM-6
  (is= '(((pizza))) (deepM 3))
  (is= '((pizza)) (deepM 2)))



; ... and now get rid of redundant let ...

(def deepM
 (let ((Rs '())
       (Ns '()))
   (fn (n)
     (let ((exists (find n Ns Rs)))
       (if (null? exists)
         (let ((result (if (zero? n) 'pizza (cons (deepM (dec n))))))
           (set! Rs (cons result Rs))
           (set! Ns (cons n Ns))
           result)
       exists)))))

(deftest test-deepM-7
  (is= '(((pizza))) (deepM 3))
  (is= '((pizza)) (deepM 2)))


(def counter)

(def consC
  (let ((N 0))
    (set! counter (fn() N))
    (fn (x y)
      (set! N (inc N))
      (cons x y))))

(defn deep (m)
  (if (zero? m) 'pizza (consC (deep (dec m)) nil)))

(deftest test-deep-with-consC
  (is= '(((pizza))) (deep 3))
  (is= 3 (counter))
  (is= '((pizza)) (deep 2))
  (is= 5 (counter)))

(defn supercounter (f)
  (letrec
    ((S (fn (n)
          (if (zero? n)
            (f n)
            (begin (f n) (S (dec n)))))))
    (S 100)))

(deftest test-supercounter
  (supercounter deep)
  (is= 5055 (counter)))

(def set-counter)

(def consC
  (let ((N 0))
    (set! counter
      (fn () N))
    (set! set-counter
      (fn (n)
        (set! N n)))
    (fn (x y)
      (set! N (inc N))
      (cons x y))))


(deftest test-deep-with-consC-2
  (is= '(((pizza))) (deep 3))
  (is= 3 (counter))
  (is= '((pizza)) (deep 2))
  (is= 5 (counter))
  (set-counter 0)
  (is= 0 (counter))
  (supercounter deep)
  (is= 5050 (counter)))


; ... and now counting conses ...

(def deepM
 (let ((Rs '())
       (Ns '()))
   (fn (n)
     (let ((exists (find n Ns Rs)))
       (if (null? exists)
         (let ((result (if (zero? n) 'pizza (consC (deepM (dec n))))))
           (set! Rs (cons result Rs))
           (set! Ns (cons n Ns))
           result)
       exists)))))


; A LISP programmer knows the value of everything but the cost of nothing
; Alan J. Perlis (1922-1990)

(deftest test-deepM-with-consC
  (set-counter 0)
  (is= '(((((pizza))))) (deepM 5))
  (is= 5 (counter))
  (is= '(((pizza))) (deepM 3))
  (is= 5 (counter))
  (is= '(((((((pizza))))))) (deepM 7))
  (is= 7 (counter))
  (supercounter deepM)
  (is= 100 (counter)))


(defn rember1*C (a l)
  (letrec
    ((R (fn (l oh)
          (cond
            ((null? l) (oh 'no))
            ((atom? (car l))
              (if (eq? (car l) a)
                (cdr l)
                (consC (car l) (R (cdr l) oh))))
            (else
              (let ((new-car (letcc oh (R (car l) oh))))
                (if (atom? new-car)
                  (consC (car l) (R (cdr l) oh))
                  (consC new-car (cdr l)))))))))
    (let ((new-l (letcc oh (R l oh))))
      (if (atom? new-l) l new-l))))


(deftest test-rember1*C-fn
  (set-counter 0)
  (is=
    '((Swedish rye) (French (mustard turkey)) salad)
    (rember1*C 'salad '((Swedish rye) (French (mustard salad turkey)) salad)))
  (is= 5 (counter))
  (set-counter 0)
  (is=
    '((pasta) pasta (noodles meat sauce) meat tomatoes)
    (rember1*C 'meat '((pasta meat) pasta (noodles meat sauce) meat tomatoes)))
  (is= 2 (counter))
  (set-counter 0)
  (is=
    '((food) more (food))
    (rember1*C 'noodles '((food) more (food))))
  (is= 0 (counter)))


(defn rember1*C2 (a l)
  (letrec
    ((R (fn (l)
          (cond
            ((null? l) nil)
            ((atom? (car l))
              (cond
                ((eq? (car l) a) (cdr l))
                (else (consC (car l) (R (cdr l))))))
            (else
              (let ((av (R (car l))))
                (cond
                  ((equal? av (car l))
                    (consC (car l) (R (cdr l))))
                  (else
                    (consC av (cdr l))))))))))
    (R l)))

(deftest test-rember2*C-fn
  (set-counter 0)
  (is=
    '((Swedish rye) (French (mustard turkey)) salad)
    (rember1*C2 'salad '((Swedish rye) (French (mustard salad turkey)) salad)))
  (is= 7 (counter))
  (set-counter 0)
  (is=
    '((pasta) pasta (noodles meat sauce) meat tomatoes)
    (rember1*C2 'meat '((pasta meat) pasta (noodles meat sauce) meat tomatoes)))
  (is= 2 (counter))
  (set-counter 0)
  (is=
    '((food) more (food))
    (rember1*C2 'noodles '((food) more (food))))
  (is= 5 (counter)))


