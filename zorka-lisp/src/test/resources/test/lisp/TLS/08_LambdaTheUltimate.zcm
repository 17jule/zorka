
; /**
;  * From book: The Little Schemer, by Daniel P. Friedman and Matthias Felleisen.
;  *
;  * Chapter 8: Lambda The Ultimate
;  */

(defn ^ (n m)
  (cond
    ((zero? m) 1)
    (else (* n (^ n (- m 1))))))


(defn rember-f (f a l)
  (cond
    ((null? l) nil)
    ((f a (car l)) (cdr l))
    (else
      (cons
        (car l)
        (rember-f f a (cdr l))))))

(deftest test-rember-f-fn
  (is= '(6 2 3) (rember-f = 5 '(6 2 5 3)))
  (is= '(beans are good) (rember-f eq? 'jelly '(jelly beans are good)))
  (is= '(lemonade and (cake)) (rember-f equal? '(pop corn) '(lemonade (pop corn) and (cake)))))



(defn eq?-c (a)
  (lambda (x)
    (eq? x a)))


(defn rember-fn (f)
  (lambda (a l)
    (cond
      ((null? l) nil)
      ((f a (car l)) (cdr l))
      (else
        (cons
          (car l)
          ((rember-fn f) a (cdr l)))))))

(deftest test-rember-fn-fn
  (is= '(shrimp salad and salad) ((rember-fn eq?) 'tuna '(shrimp salad and tuna salad)))
  (is= '(equal? eqan? eqlist? eqpair?) ((rember-fn eq?) 'eq? '(equal? eq? eqan? eqlist? eqpair?))))


; /**
;  * The Ninth Commandment:
;  *
;  * Abstract common patterns with a new function.
;  */

(defn insertL-fn (f)
  (lambda (n o l)
    (cond
      ((null? l) nil)
      ((f o (car l)) (cons n (cons o ((insertL-fn f) n o (cdr l)))))
      (else (cons (car l) ((insertL-fn f) n o (cdr l)))))))

(deftest test-insertL-fn-fn
  (is=
    '(shrimp green salad and tuna green salad)
    ((insertL-fn eq?) 'green 'salad '(shrimp salad and tuna salad))))



(defn insertR-fn (f)
  (lambda (n o l)
    (cond
      ((null? l) nil)
      ((f o (car l)) (cons o (cons n ((insertR-fn f) n o (cdr l)))))
      (else (cons (car l) ((insertR-fn f) n o (cdr l)))))))

(deftest test-insertR-fn-fn
  (is=
    '(shrimp salad pasta and tuna salad pasta)
    ((insertR-fn eq?) 'pasta 'salad '(shrimp salad and tuna salad))))


(defn seqL (n o l)
  (cons n (cons o l)))


(defn seqR (n o l)
  (cons o (cons n l)))


(defn seqS (n o l)
  (cons n l))


(defn seqRm (n o l)
  l)


(defn insert-x (f s)
  (lambda (n o l)
    (cond
      ((null? l) nil)
      ((f (car l) o) (s n o ((insert-x f s) n o (cdr l))))
      (else (cons (car l) ((insert-x f s) n o (cdr l)))))))

(deftest test-insert-x-fn
  (is=
    '(shrimp green salad and tuna green salad)
    ((insert-x eq? seqL) 'green 'salad '(shrimp salad and tuna salad)))
  (is=
    '(shrimp salad pasta and tuna salad pasta)
    ((insert-x eq? seqR) 'pasta 'salad '(shrimp salad and tuna salad)))
  (is=
    '(shrimp pasta and tuna pasta)
    ((insert-x eq? seqS) 'pasta 'salad '(shrimp salad and tuna salad)))
  (is=
    '(shrimp and tuna)
    ((insert-x eq? seqRm) 'pasta 'salad '(shrimp salad and tuna salad))))


; /**
;  * The Ninth Commandment:
;  *
;  * Abstract common patterns with a new function.
;  */

(defn insert-g (s)
  (lambda (n o l)
    (cond
      ((null? l) nil)
      ((eq? (car l) o) (s n o ((insert-g s) n o (cdr l))))
      (else (cons (car l) ((insert-g s) n o (cdr l)))))))

(deftest test-insert-g-fn
  (is=
    '(shrimp green salad and tuna green salad)
    ((insert-g seqL) 'green 'salad '(shrimp salad and tuna salad)))
  (is=
    '(shrimp salad pasta and tuna salad pasta)
    ((insert-g seqR) 'pasta 'salad '(shrimp salad and tuna salad)))
  (is=
    '(shrimp pasta and tuna pasta)
    ((insert-g seqS) 'pasta 'salad '(shrimp salad and tuna salad)))
  (is=
    '(shrimp and tuna)
    ((insert-g seqRm) 'pasta 'salad '(shrimp salad and tuna salad))))



(define insertL (insert-g seqL))

(define insertR (insert-g seqR))

(define subst (insert-g seqS))

(define remove (insert-g seqRm))

(deftest test-insertLR-subst-remove-fn
  (is=
    '(shrimp green salad and tuna green salad)
    (insertL 'green 'salad '(shrimp salad and tuna salad)))
  (is=
    '(shrimp salad pasta and tuna salad pasta)
    (insertR 'pasta 'salad '(shrimp salad and tuna salad)))
  (is=
    '(shrimp pasta and tuna pasta)
    (subst 'pasta 'salad '(shrimp salad and tuna salad)))
  (is=
    '(shrimp and tuna)
    (remove 'pasta 'salad '(shrimp salad and tuna salad))))



(defn atom-to-function (x)
  (cond
    ((eq? x '+) +)
    ((eq? x '*) *)
    (else ^)))

(define operator car)


(defn value (x)
  (cond
    ((atom? x) x)
    (else
      ((atom-to-function (cadr x)) (value (car x)) (value (caddr x))))))

(deftest test-value-fn
  (is= 42 (value '(2 + (((2 ^ 2) + (2 * 2)) + (2 * (2 ^ (2 + 2))))))))



(defn multirember-f (f)
  (lambda (a l)
    (cond
      ((null? l) nil)
      ((f (car l) a) ((multirember-f f) a (cdr l)))
      (else (cons (car l) ((multirember-f f) a (cdr l))))
    )))

(deftest test-multirember-fn
  (is=
    '(shrimp salad salad and)
    ((multirember-f eq?) 'tuna '(shrimp salad tuna salad and tuna))))



(defn multirember-t (f l)
  (cond
    ((null? lat) nil)
    ((f (car l)) (multirember-t f (cdr l)))
    (else (cons (car l) (multirember-t f (cdr l))))))


(defn multirember-co (a lat col)
  (cond
    ((null? lat) (col '() '()))
    ((eq? (car lat) a)
      (multirember-co a
        (cdr lat)
        (lambda (newlat seen)
          (col newlat (cons (car lat) seen)))))
    (else
      (multirember-co a
        (cdr lat)
        (lambda (newlat seen)
          (col (cons (car lat) newlat) seen))))))

(defn a-friend (x y)
  (null? y))

(defn new-friend (newlat seen)
  (a-friend newlat
    (cons 'tuna seen)))

(defn latest-friend (newlat seen)
    (a-friend (cons 'and newlat) seen))

(defn last-friend (x y)
  (length x))

(deftest test-multirember-co-fn
  (is (multirember-co 'tuna '() a-friend))
  (isnt (multirember-co 'tuna '(tuna) a-friend))
  (is= 3 (multirember-co 'tuna '(strawberries tuna and swordfish) last-friend)))



(defn multiinsertLR (new oldL oldR lat)
  (cond
    ((null? lat)
      nil)
    ((eq? (car lat) oldL)
      (cons new (cons oldL (multiinsertLR new oldL oldR (cdr lat)))))
    ((eq? (car lat) oldR)
      (cons oldR (cons new (multiinsertLR new oldL oldR (cdr lat)))))
    (else
      (cons (car lat) (multiinsertLR new oldL oldR (cdr lat))))))


(defn multiinsertLR-co (new oldL oldR lat col)
  (cond
    ((null? lat) (col nil 0 0))
    ((eq? (car lat) oldL)
      (multiinsertLR-co new oldL oldR (cdr lat)
        (lambda (newlat L R)
          (col (cons new (cons oldL newlat)) (+ 1 L) R))))
    ((eq? (car lat) oldR)
      (multiinsertLR-co new oldL oldR (cdr lat)
        (lambda (newlat L R)
          (col (cons oldR (cons new newlat)) L (+ 1 R)))))
    (else
      (multiinsertLR-co new oldL oldR (cdr lat)
        (lambda (newlat L R)
          (col (cons (car lat) newlat) L R))))))

(deftest test-multiinsertLR-co-fn
  (is=
    '((chips salty and salty fish or salty fish and chips salty) 2 2)
    (multiinsertLR-co 'salty 'fish 'chips '(chips and fish or fish and chips) (lambda args args))))


(defn evens-only* (l)
  (cond
    ((null? l) nil)
    ((atom? (car l))
      (cond
        ((even? (car l))
          (cons (car l) (evens-only* (cdr l))))
        (else (evens-only* (car l)))))
    (else
      (cons
        (evens-only* (car l))
        (evens-only* (cdr l))))))


(defn evens-only*-co (l col)
  (cond
    ((null? l) (col nil 1 0))
    ((atom? (car l))
      (cond
        ((even? (car l))
          (evens-only*-co (cdr l)
            (lambda (n p s)
              (col (cons (car l) n) (* (car l) p) s))))
        (else
          (evens-only*-co (cdr l)
            (lambda (n p s)
              (col n p (+ s (car l))))))))
    (else
      (evens-only*-co (car l)
        (lambda (n1 p1 s1)
          (evens-only*-co (cdr l)
            (lambda (n2 p2 s2)
              (col
                (cons n1 n2)
                (* p1 p2)
                (+ s1 s2)))))))))


(defn the-last-friend (n p s)
  (cons s (cons p n)))


(deftest test-evens-only*-co-fn
  (is=
    '(38 1920 (2 8) 10 (nil 6) 2)
    (evens-only*-co '((9 1 2 8) 3 10 ((9 9) 7 6) 2) the-last-friend)))

