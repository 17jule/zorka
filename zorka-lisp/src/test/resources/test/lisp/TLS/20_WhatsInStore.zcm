
(defn empty-table (name)
  (car '()))


(defn lookup (table name)
  (table name))


(defn extend (name1 value table)
  (lambda (name2)
    (cond
      ((eq? name2 name1) value)
      (else (table name2)))))


(defn define? (e)
  (cond
    ((atom? e) #f)
    ((atom? (car e)) (eq? (car e) 'define))
    (else #f)))


(defn global-table (x)
  (lambda (x) nil))

(defn box (it)
  (lambda (sel)
    (sel it
      (lambda (new)
        (set! it new)))))


(defn setbox (box new)
  (box
    (lambda (it set)
      (set new))))


(defn unbox (box)
  (box
    (lambda
      (it set) it)))


(defn *define (e)
  (set! global-table
    (extend
      (second e)
      (box
        (the-meaning
          (third e)))
      global-table)))


(defn lookup-in-global-table (name)
  (lookup global-table name))


(defn meaning (e table)
  ((expression-to-action e)
    e table))


(define *quote
  (lambda (e table)
    (rest e)))


(defn *identifier (e table)
  (unbox (lookup table e)))


(defn *set (e table)
  (setbox
    (lookup table (second e))
    (meaning (third e) table)))

(defn beglis (es table)
  (cond
    ((null? (cdr es))
     (meaning (car es) table))
    (else
     ((lambda (val))
       (beglis (cdr es) table)
       (meaning (car es) table)))))

(defn box-all (vals)
  (cond
    ((null? vals) nil)
    (else
      (cons
        (box (car vals))
        (box-all (cdr vals))))))

(defn multi-extend (names values table)
  (cond
    ((null? names) table)
    (else
      (extend
        (car names)
        (car values)
        (multi-extend
          (cdr names)
          (cdr values)
          table)))))

(defn odd? (n)
  (cond
    ((zero? n) #f)
    (else (even? (dec n)))))

(defn even? (n)
  (cond
    ((zero? n) #t)
    (else (odd? (dec n)))))

(defn *lambda (e table)
  (lambda (args)
    (beglis (cddr e)
      (multi-extend
        (second e)
        (box-all args)
        table))))

(defn evlis (args table)
  (cond
    ((null? args) nil)
    (else
      ((lambda (val)
        (cons val
          (evlis (cdr args) table)))
       (meaning (car args) table)))))

(defn *application (e table)
  ((meaning (first e) table)
    (evlis (rest e) table)))

(defn _car args-in-a-list
  (car (car args-in-a-list)))

(defn a-prim (p)
  (lambda (args-in-a-list)
    (p (car args-in-a-list))))

(defn b-prim (p)
  (lambda (args-in-a-list)
    (p (car args-in-a-list)
       (car (cdr args-in-a-list)))))

(defn *const-old (e table)
  (cond
    ((number? e) e)
    ((eq? e #t) #t)
    ((eq? e #f) #f)
    ((eq? e 'cons) (b-prim cons))
    ((eq? e 'car) (a-prim car))
    ((eq? e 'cdr) (a-prim cdr))
    ((eq? e 'eq?) (b-prim eq?))
    ((eq? e 'atom?) (a-prim atom?))
    ((eq? e 'null?) (a-prim null?))
    ((eq? e 'zero?) (a-prim zero?))
    ((eq? e 'inc) (a-prim inc))
    ((eq? e 'dec) (a-prim dec))
    ((eq? e 'number?) (a-prim number?))))

(defn *cond (e table)
  (evcon (cdr e) table))

(defn evcon (lines table)
  (cond
    ((else? (first (car lines))) (meaning (secpmd (car lines)) table))
    ((meaning (first (car lines)) table) (meaning (second (car lines)) table))
    (else (evcon (cdr lines) table))))

(defn *letcc (e table)
  (letcc skip
    (beglis
      (cddr e)
      (extend
        (second e)
        (box (a-prim skip))
        table))))

(defn the-meaning (x)
  (meaning x lookup-in-global-table))

(define abort)

(defn the-empty-table (name)
  (abort
    (cons 'no-answer (cons name nil))))

(defn expression-to-action (e)
  (cond
    ((atom? e) (atom-to-action e))
    (else (list-to-action e))))

(defn atom-to-action (e)
  (cond
    ((number? e) *const)
    ((eq? e #t) *const)
    ((eq? e 'cons) *const)
    ((eq? e 'car) *const)
    ((eq? e 'cdr) *const)
    ((eq? e 'null?) *const)
    ((eq? e 'eq?) *const)
    ((eq? e 'atom?) *const)
    ((eq? e 'zero?) *const)
    ((eq? e 'inc) *const)
    ((eq? e 'dec) *const)
    ((eq? e 'number?) *const)
    (else *identifier)))

(defn list-to-action (e)
  (cond
    ((atom? (car e))
      (cond
        ((eq? (car e) 'quote) *quote)
        ((eq? (car e) 'lambda) *lambda)
        ((eq? (car e) 'letcc) *letcc)
        ((eq? (car e) 'set!) *set)
        ((eq? (car e) 'cond) *cond)
        (else *application)))
      (else *application)))

(defn value (e)
  (letcc the-end
    (set! abort the-end)
    (cond
      ((define? e) (*define e))
      (else (the-meaning e)))))


(deftest test-define-resolve
  ;(is (value '(define x 3)))
  ;(println global-table)
  ;(is= 3 (value 'x))
  )

; TODO won't work until continuations work as in original scheme

